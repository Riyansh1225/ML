# Examples for ndarray Concept :: 

# numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0) --> This is syntax of the array object in 

# In this example depending on dtype output values will be changed. 
# Means we can convert the elements in an array by defining the data type.
# One important point is Numpy was Implemented in C languag.

import numpy as np
a=np.array([1,2,3,4,5,6], dtype = int )
print(a)

Output ::

[1 2 3 4 5 6]

# Run the same program in 2 dimensions array 

import numpy as np
a=np.array([[1,2,3,4],[5,6,7,8]] , dtype = float )
print (a)

Output :: 

[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]


# Examples for Data type in NumPy  :: 

#  numpy.dtype(object, align, copy)  --> This is syntax of dtype in Numpy.

# This is basic example of the Numpy array

import numpy as np
a=np.dtype(int)
print (a)

Output :: 
int32

#int8, int16, int32, int64 can be replaced by equivalent string 'i1', 'i2','i4', etc.

import nupy as np
a=np.dtype('i4')
print (a)

OutPut :: 
int32

# Create structured data type and used to display the contenent on the array 

import numpy as np
a=np.dtype([('Name','S20'),('Marks','i4'),('Ranks','i4')])
b=np.array([('Phani',70,4),('Ram',60,5),('Sai',59,6)] , dtype=a)
print (b['Marks'])

OutPut :: [70 60 59]

#Examples for Array Attributes in Numpy 

# Display shape of the array ( Matrix formte : Rows * Columns )

import numpy as np
a=np.array([(1,2,3,4,5,6,7),(3,4,5,6,7,8,9)], dtype=int)
print (a.shape)

OutPut :: (2, 7)

# We can reshape the matrix 

import numpy as np
a=np.array([(1,2,3),(4,5,6)], dtype=float)
print (a.shape)
b = a.reshape(3,2)
print(b)

OutPut ::

(2, 3)

[[1. 2.]
 [3. 4.]
 [5. 6.]]

# We can resize the matrix

import numpy as np
a=np.array([(1,2,3),(4,5,6)], dtype=float)
print (a.shape)
a.shape=(3,2)
print(a)

OutPut ::
(2, 3)

[[1. 2.]
 [3. 4.]
 [5. 6.]]


# An array of evenly spaced numbers

import numpy as np
a=np.arange(15)
print (a)

Output :: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]

# Display the list of numbers in a range. Here End number won't be considered.

import numpy as np
a=np.arange(16).reshape(4,2,2)
print (a)
a.ndim

OutPut ::

[[[ 0  1]
  [ 2  3]]

 [[ 4  5]
  [ 6  7]]

 [[ 8  9]
  [10 11]]

 [[12 13]
  [14 15]]]
  
  a.ndim
  
  3

## Size , Itemsize and nbytes  Definations 

# Size :: This will display the number of elements in an array

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.size)

Output :: 10

# itemsize :: This will display memory used by each array element in an array

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.itemsize)

Output :: 4 

# nbytes :: The total number of bytes required to store array data ( size * item size )

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.nbytes)

Output :: 40 

# Flags in Numpy Library

import numpy as np
x = np.array([1,2,3,4,5])
print x.flags

Output ::

C_CONTIGUOUS : True
F_CONTIGUOUS : True
OWNDATA : True
WRITEABLE : True
ALIGNED : True
UPDATEIFCOPY : False

# Numpy ---> ARRAY CREATION ROUTINES

# numpy.empty --> It creates an uninitialized array of specified shape and dtype. It uses the following constructor.

Syntax :: numpy.empty(shape, dtype=float, order='C')

Note :: The elements in an array show random values as they are not initialized.

import numpy as np
a=np.empty((3,2),dtype=int)
print (a)

Output :: 

[[         0 1074266112]
 [         0 1073741824]
 [         0 1074266112]]
 
 #numpy.zeros --> Returns a new array of specified size, filled with zeros.
 
 synatx --> numpy.zeros(shape, dtype=float, order='C')
 
 import numpy as np
 a=np.zeros([2,3,4], dtype = float)
 print (a) 
 
 Output ::
 
 [[[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
  
  #numpy.ones --> Returns a new array of specified size and type, filled with ones
  
  Syntax : numpy.ones(shape, dtype=None, order='C')
  
 import numpy as np
 a=np.ones([2,3,4], dtype = float)
 print (a) 
 
  Output ::
  
  [[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]]
  
# NUMPY − ARRAY FROM EXISTING DATA ::

#numpy.asarray --> This function is similar to numpy.array except for the fact that it has fewer parameters. 
#This routine is useful for converting Python sequence into ndarray.

#Synatax --> numpy.asarray(a, dtype=None, order=None)

import numpy as np
a=np.asarray([1,2,3,4,5,6,7] , dtype = complex )
print (a)

Output :: [1.+0.j 2.+0.j 3.+0.j 4.+0.j 5.+0.j 6.+0.j 7.+0.j]

# numpy.frombuffer --> This function interprets a buffer as one-dimensional array.
# Any object that exposes the buffer interface is used as parameter to return an ndarray.

Syntax --> numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)

import numpy as np
b="My first Python Program"
a=np.frombuffer(b,dtype=S1)
print (a)

Output :: Not working in Spyder , Need to check in Jupyter note pad.

#This function builds an ndarray object from any iterable object. 
# A new one-dimensional array is returned by this function.
Syntax --> numpy.fromiter(iterable, dtype, count=-1)

import numpy as np
def gen_c():
    c = np.ones(5, dtype=int)
    j = 0
    t = 10
    while j < t:
        c[0] = j
        for i in c:
            yield i
        j += 1

np.fromiter(gen_c(),dtype=int).reshape((10,5))

Output ::

array([[0, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [2, 1, 1, 1, 1],
       [3, 1, 1, 1, 1],
       [4, 1, 1, 1, 1],
       [5, 1, 1, 1, 1],
       [6, 1, 1, 1, 1],
       [7, 1, 1, 1, 1],
       [8, 1, 1, 1, 1],
       [9, 1, 1, 1, 1]])
  
# NUMPY − ARRAY FROM NUMERICAL RANGES

numpy.arange --> This function returns an ndarray object containing evenly spaced values within a given range.
Syntax --> numpy.arange(start, stop, step, dtype)

import numpy as np
a=np.arange(3,30,3)
print (a)

Output :: 

[ 3  6  9 12 15 18 21 24 27]

# numpy.linspace  --> This function is similar to arange() function. 
# In this function, instead of step size, the number of evenly spaced values between the interval is specified.

Syntax --> numpy.linspace(start, stop, num, endpoint, retstep, dtype)

import numpy as np
a=np.linspace(2,40,10)
print (a)

Output ::

[ 2.          6.22222222 10.44444444 14.66666667 18.88888889 23.11111111
 27.33333333 31.55555556 35.77777778 40.        ]
 

# numpy.linspace -->  Return evenly spaced numbers over a specified interval.
# Returns num evenly spaced samples, calculated over the interval [start, stop].
# The endpoint of the interval can optionally be excluded.

Syntax --> numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)

start --> Starting value of the sequence. 
Stop  --> The end value of the sequence, unless endpoint is set to False.

import numpy as np
a=np.linspace(2,3,4 , endpoint = False , retstep = True )
print (a)

OutPut ::  
         (array([2.  , 2.25, 2.5 , 2.75]), 0.25) 
         
         Here 0.25 is step size in a sample array.

In the above example, if we don't specify the retstep as True, step size won't be displayed.

# numpy.logspace  --> Return numbers spaced evenly on a log scale.

# In linear space, the sequence starts at base ** start (base to the power of start) and ends with base ** stop

Syntax --> numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)

import numpy as np
a=np.linspace(1,10,num=10)
print (a)

Output :: [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]

import numpy as np
a=np.logspace(1,10,num=9,dtype=int,endpoint=false)
print (a)

Output :: [         10         100        1000       10000      100000     1000000
    10000000   100000000  1000000000 -2147483648]
  

import numpy as np
a=np.logspace(1,10,num=9,dtype=int,base=2,endpoint=False)
print (a)

Output :: [  2   4   8  16  32  64 128 256 512]

********************************* Indexing and Slicing *************************************

indexing or slicing, just like Python's in-built container objects. Items in ndarray are based on zero-based index. 

Below are 3 types of methods are available 

1.field access 
2.basic slicing 
3.adavanced indexing 

1.Filed accesss ::

import numpy as np
a=np.arange(24)
print (a)
b=a[2:7:2]
print (b)

Output ::

print (a) :: 

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]

print (b) :: 

[2 4 6]


2.Basic Slicing ::

import numpy as np
a=np.arange(5)
print (a)
b=a[2:]
print (b)

Output ::

print (a) ::

[0 1 2 3 4]

Print (b) ::
[2 3 4]

Anothe Example for Simple Slicing ::

import numpy as np
a=np.array([[1,2,3],[4,5,6],[7,8,9]], dtype = int)
print (a)
b=a[-2:]
print (b)

Output ::

print (a) ::

[[1 2 3]
 [4 5 6]
 [7 8 9]]
 
print (b) ::

[[4 5 6]
 [7 8 9]]
 
 
#Accessing the column values from the matrix. we can use ellipsis(...) to get the column or row values in particular.
#If we place the ellipsis in the row position, it will get you the all the values of particular column
c=np.array([[1,2,3,4],[5,6,7,8],[9,8,7,6]],int)
c
c[...,1]
c[1,...]
c[...,2]

#Accessing the row values from diagonal matrix.If we place the ellipsis in the column value 
#position, it will get you the all the values of particular row mentioned
c[1]
c[1,...]

#Slicing
a=np.arange(20)
a
a[5:20:5]
a[:4] #means from 0th index to before 4th index.
a[:10]
a[1:5] #means from first index to before 5th index.
a[5:] #means from 5th index to last index.
a[::4] #means multiples of 4 until last values.
a[0]

************************************ Advanced Indexing *****************************************

# This mechanism helps in selecting any arbitrary item in an array based on its Ndimensional index.
# Each integer array represents the number of indexes into that dimension. 
# When the index consists of as many integer arrays as the dimensions of the target ndarray, it becomes straightforward.

Simple Indexing example ::

import numpy as np
a=np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])
print (a)
print(a[[1,2,1,0],[0,2,3,3]])

Output ::
print (a) :: 

[[ 1  2  3  4]
 [ 4  5  6  7]
 [ 7  8  9 10]]

print (b) :: [4 9 7 4]

#############

import numpy as np 
x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
print (x)
rows = np.array([[0,0],[3,3]])
print (rows)
cols = np.array([[0,2],[0,2]])
print (cols) 
y = x[rows,cols] 
print (y)


Output ::

print (x) :
 [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (rows) ::
 
 [[0 0]
 [3 3]]
 
 print (cols) ::
 
 [[0 2]
 [0 2]]
 
 print (y) ::
 
 [[ 0  2]
 [ 9 11]]
 
 ######################################
 
 # The advanced and basic indexing can be combined using one slic(:) or ellipise (...) with an index array. 
    
import numpy as np 
x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
print (x)
# slicing 
a = x[1:4]
print (a)
b = x[1:3]
print (b)
z = x[1:4,1:3] 
print (z) 

# using advanced index for column 
y = x[1:4,[1,2]] 

print (y)

Output :: 
print (x) ::

 [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (a) ::
 
 [[ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (b) ::
 
 [[3 4 5]
 [6 7 8]]
 
 print (z) ::
 
 [[ 4  5]
 [ 7  8]
 [10 11]]
 
 print (y) ::
 
 [[ 4  5]
 [ 7  8]
 [10 11]]
 
 ***************************************************************
# Boolen array indexing 
# This type of advanced indexing is used when the resultant object is meant to be the result of Boolean operations, 
# such as comparison operators.

import numpy as np
a=np.array([[0,1,2,3],[4,5,6,7],[6,7,8,9]])
print (a)
print (a[a>3])

Output :: 

[[0 1 2 3]
 [4 5 6 7]
 [6 7 8 9]]
 
 [4 5 6 7 6 7 8 9]
 
 #####################
 
 # In this example, NaN (Not a Number) elements are omitted by using ~ (complement operator)
 
 import numpy as np
 a=np.array([[1,2,np.nan,3],[4,5,6,np.nan],[9,8,7,6]])
 print (a)
 print (a[np.isnan(a)])
 print (a[~np.isnan(a)])
 
Output ::
print (a) ::

[[ 1.  2. nan  3.]
 [ 4.  5.  6. nan]
 [ 9.  8.  7.  6.]]
 
 print (a[np.isnan(a)]) :: [nan nan]
 print (a[~np.isnan(a)]) ::
 
 [1. 2. 3. 4. 5. 6. 9. 8. 7. 6.]
 
 ###########################################
 
 #The following example shows how to filter out the non-complex elements from an array.
 
import numpy as np 
a = np.array([1, 2+6j, 5, 3.5+5j]) 
print a[np.iscomplex(a)]

Output ::

[2.0+6.j  3.5+5.j] 

*************** Numpy - Broadcasting ***************************************************

# The Broadcasting refers to ability of Numpy to treat arrays of different shapes during arithmetic operations. 
# The arithmetic operations on two arrays normally done on array elements.
# if the arrays of same size we don't have any Issues.The arithmatic operations on different sizes will make some difficult.

# This is simple example of multiplication of two arrays of same size 

import numpy as np
a=np.array([[1,2,3],[4,5,6],[7,8,9]])
print (a)
b=np.array([[1,2,3],[4,5,6],[7,8,9]])
print (b)
c= a*b
print (c)

Output ::

print (a) ::

[[1 2 3]
 [4 5 6]
 [7 8 9]]
 
 print (b) ::
 
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
 
 print (c) ::
 
 [[ 1  4  9]
 [16 25 36]
 [49 64 81]]
 
 
# Multiplication of two matrix. Below is thumb rule for the same.
# The number of columns in first matrix is equal to number of rows in secons matrix.
# Below is some example for the same.
# We don't have separate functions in Numpy to support this functionality. Normal for Or while loops we need to use for same.
 

import numpy as np
A=np.array([[12,7,3],[4,5,6],[7,8,9]])
B=np.array([[5,8,1,2],[6,7,3,0],[4,5,9,1]])
C=np.array([[0,0,0,0],[0,0,0,0],[0,0,0,0]])
	
# iterating by row of A 
for i in range(len(A)): 

	# iterating by coloum by B 
	for j in range(len(B[0])): 

		# iterating by rows of B 
		for k in range(len(B)): 
			C[i][j] += A[i][k] * B[k][j] 

for r in C: 
	print(r) 
 
 Output ::
 
[114 160  60  27]
[74  97   73  14]
[119 157 112  23]

################################################################################

# Numpy Package contains the Iteration object. It is efficient multidimensional iteration object. 
# Using this object which we can iterate the each element in the array.

# This is sample program to iterate all the objects in an array.

import numpy as np
a=np.arange(0,60,5)
print (a)
a=a.reshape(4,3)
print (a)

for x in np.nditer(a):
    print (x)
    
OutPut :: 

print (a) :: [ 0  5 10 15 20 25 30 35 40 45 50 55]

print (a) :: 

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
print (x) ::

0
5
10
15
20
25
30
35
40
45
50
55
 
# Reading memory in contigous location is faster than jumping around among locations. 
# As a result, if the matrix stored in row-major order , then iterating through its elements sequencetially in row-major order
# may be faster than iterating elements in column-major order.

# C uses row major and Fortan uses Column major order. 
# Transpose means chaning columns to rows and rows to columns in a matrix.
 
import numpy as np
a=np.arange(0,60,5)
print (a)
print ('\n')
print (a.T)
a=a.reshape(4,3)
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
for x in np.nditer(a.T.copy(order='C')):
    print (x)
    
Output ::

print (a) :: [ 0  5 10 15 20 25 30 35 40 45 50 55]

print (a.T) :: [ 0  5 10 15 20 25 30 35 40 45 50 55] 

After reshape the array 

print (a) ::

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
 print (a.T) ::
 
 [[ 0 15 30 45]
 [ 5 20 35 50]
 [10 25 40 55]]
 
  print (x) ::
  
0
15
30
45
5
20
35
50
10
25
40
55

# In the below example , just chaning the order from C to Fortan.

import numpy as np
a=np.arange(0,60,5)
print (a)
print ('\n')
print (a.T)
a=a.reshape(4,3)
print ('\n After reshape the array')
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
for x in np.nditer(a.T.copy(order='F')):
    print (x)
    
Output ::

0
5
10
15
20
25
30
35
40
45
50
55


# Modifying the array values using nditer object.
# By default ,the nditer object treats the input operand as read-only object.To be able to modify the array elements, you must specify the 
# read-write or write-only mode using the 'readwrite' or 'writeread' per-operand flag.	
# The nditer object has another optional parameter called op_flags.

# Below one is one simple example of how the nditer object is modying the array.

    
import numpy as np
a=np.arange(0,60,5)
a=a.reshape(4,3)
print ('\n After reshape the array')
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
b=a.T.copy(order='C')
print (b)
for x in np.nditer(b , op_flags = ['readwrite']):
    x[...] = 2*x
    print (x)
    
 Output ::
 
 Print (b) ::
 
 [[ 0 15 30 45]
 [ 5 20 35 50]
 [10 25 40 55]]
 
 print (x) ::
 
 0
30
60
90
10
40
70
100
20
50
80
110


# One more example for Modying the nditer array element.

import numpy as np
a=np.arange(0,60,5)
a=a.reshape(4,3)
print (a)
with np.nditer(a,op_flags=['readwrite']) as it:
    for x in it:
        x[...] = 2*x
print (a)

Output ::

print (a) ::

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
 print (a) ::
 
 [[  0  10  20]
 [ 30  40  50]
 [ 60  70  80]
 [ 90 100 110]]
 
 
 # In the above example we are using WITH statement. Here WITH statement used as context manager. 
 # The temporary data will be written back when the context is exited.
 # One more method is ,  call the close method one finished iterating , which will triger the write-back.
 
 #### Using the External loop # #######
 
 import numpy as np 
a = np.arange(6) 
a = a.reshape(2,3) 
print (a)
for x in np.nditer(a, flags = ['external_loop'], order = 'F'):
   print (x,end=' ')
   
   Output ::
 
 [[0 1 2]
 [3 4 5]]
 
 print (x,end=' ') ::
 
 [0 3] [1 4] [2 5] 
 
# In this case, there is some difference when the print statement contains the  print (x,end=' ') and print (x)

************************************NumPy - Array Manipulation********************************************************
***********Changing Shape *******

# There are several routines are availeble in Numpy package for manipulation of elements in ndarray object. Below are some of the operations.

# reshape --> We have seen this command examples in above examples. 
# This will change the shape of the array with out chaning the elements in the array.

#flat --> This function returns a 1-D iterator over the array.

import numpy as np
a=np.arange(6).reshape(3,2)
print (a)
b=a.flat[3]
print (b)

Output :: 

print (a) :: 
[[0 1]
 [2 3]
 [4 5]]

print (b) ::

3

# flatten -->  This function returns a copy of an array collapsed into one dimension. 
# Syntax --> ndarray.flatter(order)

import numpy as np
a=np.arange(6).reshape(3,2)
print (a)
b=a.flatten(order='F')
print (b)

Output ::
print (a) 
[[0 1]
 [2 3]
 [4 5]]

print (b) :: 

[0 2 4 1 3 5] 

import numpy as np
a=np.arange(6).reshape(3,2)
print (a)
b=a.flatten(order='c')
print (b)

Output ::

print (a) ::

[[0 1]
 [2 3]
 [4 5]]
 
 print (b) :: [0 1 2 3 4 5] 
 
 # ravel --> This function returns a flattened one-dimensional array. A copy is made only if needed.
 # The returned array will have the same type as that of the input array. The function takes one parameter.
 
import numpy as np
a=np.arange(6).reshape(3,2).ravel(order='c')
print (a)

Output ::

[0 1 2 3 4 5]

import numpy as np
a=np.arange(6).reshape(3,2).ravel(order='F')
print (a)

Output ::

[0 2 4 1 3 5]

############ Below are some of Transpose Operations in *********** Numpy Array Manipulation##########################

# transpose --> This operation will convert rows to columns and columns to rows.

import numpy as np
a=np.arange(6).reshape(3,2)
print (a)
b=np.transpose(a)
print (b)

Output ::

print (a) :: 
[[0 1]
 [2 3]
 [4 5]]
 
 print (b) :: 
 
 [[0 2 4]
 [1 3 5]]
 
 # ndarray.T  --> This operation will convert rows to columns and columns to rows.
 
import numpy as np
a=np.arange(6).reshape(3,2)
print (a)
b=a.T
print (b)
 
Output ::

print (a) :: 
[[0 1]
 [2 3]
 [4 5]]
 
 print (b) :: 
 
 [[0 2 4]
 [1 3 5]]
 
 #moveaxis --> This function moves the axes of array to new position.
 # Other axes remain in their original order.
 # Synatx --> moveaxis(array,source,destionation)
 
import numpy as np
a = np.ones((3,4,5))
a.shape
b=np.moveaxis(a,0,1)
b.shape

Output ::

a.shape :: ( 3,4,5)
b.shape :: ( 4,3,5)

# swapaxes --> Need to discuss more on this function , at the time of discussion.
 
# Broadcaset --> Need to discuss more on this function , at the time of discussion.

import numpy as np
a=np.array([[1],[2],[3],[4]])
b=np.array([1,2,3,4])
print (a)
print (b)
a.shape
b.shape
c=a+b
print (c)

Output ::

print (a) ::
[[1]
 [2]
 [3]
 [4]]
 
 print (b) ::
  [1 2 3 4]
  
  print (c) ::
  
 [[2 3 4 5]
 [3 4 5 6]
 [4 5 6 7]
 [5 6 7 8]]


 #broadcast_to --> This function broadcasts to new shape. It returns read-only view on the original array.
 # Syntax ---> numpy.broadcast_to(array, shape, subok)
 
import numpy as np 
a=np.array([[1,2,3,4,5,6,7]])
print (a)
b=np.broadcast_to(a,(5,7))
print (b) 

Output ::

print (a) ::

[[1 2 3 4 5 6 7]]

print (b) ::

[[1 2 3 4 5 6 7]
 [1 2 3 4 5 6 7]
 [1 2 3 4 5 6 7]
 [1 2 3 4 5 6 7]
 [1 2 3 4 5 6 7]]
 
 # expand_dims --> This function expands the array by inserting a new axis at the specified position.
 # Syntax --> numpy.expand_dims(arr, axis) 

 import numpy as np 
x = np.array(([1,2],[3,4])) 
print (x)
y = np.expand_dims(x, axis = 0) 
print (y)
y = np.expand_dims(x, axis = 1) 
print (y)

Output ::

print (x) ::

[[1 2]
 [3 4]]
 
 print (y) ::
 
 [[[1 2]
  [3 4]]]
  
  print (y) ::
  
  [[[1 2]]

 [[3 4]]]
 
 
 # numpy.squeeze --> This function removes one-dimensional entry from the shape of the given array. 
 # Two parameters are required for this function. 
 
 Syntax --> numpy.squeeze(arr, axis)
 
import numpy as np  
x = np.arange(9).reshape(1,3,3) 
print (x)
x.shape
y = np.squeeze(x) 
print (y)
y.shape

Output ::
print (x) :: 
[[[0 1 2]
  [3 4 5]
  [6 7 8]]]
  
  x.shape -->  (1,3,3)
  
print (y) ::

[[0 1 2]
 [3 4 5]
 [6 7 8]]

y.shape --> (3,3)


############ Below are some of Joining Arrays Operations in *********** Numpy Array Manipulation##########################

# numpy.concatenate --> Concatenation refers to joining. 
# This function is used to join two or more arrays of the same shape along a specified axis.

Synatx --> numpy.concatenate((a1, a2, ...), axis)

import numpy as np
a=np.array([[1,2,3],[4,5,6],[6,7,8]])
b=np.array([[3,4,5],[7,8,9],[9,2,3]])
print (a)
print (b)
c=np.concatenate((a,b),axis=0)
print (c)
print(b.T)
c=np.concatenate((a,b.T),axis=1)
print (c)

Output ::

print (a) ::

[[1 2 3]
 [4 5 6]
 [6 7 8]]
 
 print (b) ::
 
 [[3 4 5]
 [7 8 9]
 [9 2 3]]
 
 print (c) ::
 
 [[1 2 3]
 [4 5 6]
 [6 7 8]
 [3 4 5]
 [7 8 9]
 [9 2 3]]
 
 print(b.T) ::
 
 [[3 7 9]
 [4 8 2]
 [5 9 3]]
 
 print (c) ::
 
 [[1 2 3 3 7 9]
 [4 5 6 4 8 2]
 [6 7 8 5 9 3]]
 
 
 # numpy.stack --> This function joins the squences of arrays along with a new axis.
 # Syntax --> numpy.stack(arrays, axis=0, out=None) 
 # The axis parameter specifies the index of the new axis in the dimensions of the result.
 # For example, if axis=0 it will be the first dimension and if axis=-1 it will be the last dimension.
 
import numpy as np
a = np.array([[1,2],[3,4]]) 
b = np.array([[5,6],[7,8]]) 
print (a)
print (b)
print (  np.stack((a,b),0) )
print (  np.stack((a,b),1) )

Output :: 
print (a) ::

[[1 2]
 [3 4]]
 
 print (b) ::
 
 [[5 6]
 [7 8]] 
 
 print (  np.stack((a,b),0) ) ::
 
 [[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
  
  print (  np.stack((a,b),1) ) ::
  
  [[[1 2]
  [5 6]]

 [[3 4]
  [7 8]]]


# numpy.hstack ---> Stacks arrays in sequence horizontally (column wise).

import numpy as np
a = np.array((1,2,3))
b = np.array((2,3,4))
np.hstack((a,b))

Output :;

array([1, 2, 3, 2, 3, 4])

import numpy as np
a = np.array([[1],[2],[3]])
b = np.array([[2],[3],[4]])
print (a)
print (b)
np.hstack((a,b))

Output ::

print (a) ::

[[1]
 [2]
 [3]] 
 
 print (b) ::
 
 [[2]
 [3]
 [4]] 
 
 np.hstack((a,b)) ::
 
 array([[1, 2],
       [2, 3],
       [3, 4]])

# Vstack ---> Stack arrays in sequence vertically (row wise).

a = np.array([1, 2, 3])
b = np.array([2, 3, 4])
print (np.vstack((a,b)))

Output ::

[[1, 2, 3],
[2, 3, 4]]
       

a = np.array([[1], [2], [3]])
b = np.array([[2], [3], [4]])
np.vstack((a,b))

Output ::

[[1]
 [2]
 [3]
 [2]
 [3]
 [4]]
 
 
 ############ Below are some of Splitting Arrays Operations in *********** Numpy Array Manipulation##########################

# split --> This function divides the array into subarrays along a specified axis.
# Synatx --> numpy.split(ary, indices_or_sections, axis)
# indices_or_sections --> This is an integer , doesn't equally divid the arrya. 
# For an array of length l that should be split into n sections, it returns l % n sub-arrays of size l//n + 1 and the rest of size l//n.

import numpy as np 
a = np.arange(11)
print (a)
b=np.array_split(a,3)
print (b)

Output ::

print (a) ::

[ 0  1  2  3  4  5  6  7  8  9 10]

print (b) ::

[array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8,  9, 10])]

Example 2 ::

import numpy as np 
a = np.arange(8)
print (a)
b=np.array_split(a,3)
print (b)


Output ::

print (a) ::
[0 1 2 3 4 5 6 7]

print (b) ::

[array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]

# numpy.hsplit ---> The hsplit() function is used to split an array into multiple sub-arrays horizontally (column-wise).
hsplit is equivalent to split with axis=1, the array is always split along the second axis regardless of the array dimension.


import numpy as np 
a = np.arange(16).reshape(4,4) 
print (a)
b = np.hsplit(a,2) 
print (b)

Output ::
print (a) ::

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
 
 print (b) ::
 
 [array([[ 0,  1],
       [ 4,  5],
       [ 8,  9],
       [12, 13]]), 
       
  array([[ 2,  3],
       [ 6,  7],
       [10, 11],
       [14, 15]])]

Example #2 ::

import numpy as np 
a = np.arange(12)
print (a)
b=np.hsplit(a,2)
print (b) 

Output ::

print (a) :: [ 0  1  2  3  4  5  6  7  8  9 10 11]

print (b) :: 

[array([0, 1, 2, 3, 4, 5]), array([ 6,  7,  8,  9, 10, 11])]

#numpy.vsplit --> The vsplit() function is used to split an array into multiple sub-arrays vertically (row-wise).
# vsplit is equivalent to split with axis=0 (default), the array is always split along the first axis regardless of the array dimension.

Example 1# ::

import numpy as np 
a = np.arange(16).reshape(4,4) 
print (a)
b = np.vsplit(a,2) 
print (b)

Output ::

print (a) ::

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
 
 print (b) ::
 
 [array([[0, 1, 2, 3],
       [4, 5, 6, 7]]), 
 array([[ 8,  9, 10, 11],
       [12, 13, 14, 15]])]


############ Below are some of Adding / Removing Elements Operations in *********** Numpy Array Manipulation########################

# numpy.resize(arr, shape) --> The resize() function is used to create new array with the specified shape.
# If the new array is larger than the original array, then the new array is filled with repeated copies of a.
# Return value :: The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. 
# The data are repeated in the order that they are stored in memory.

Example 1 ::

import numpy as np
a= np.array([[1,2], [3,4]])
print (a)
b=np.resize(a, (3,2))
print (b)

Output ::

print (a) ::

[[1 2]
 [3 4]]
 
print (b) ::

[[1 2]
 [3 4]
 [1 2]]
 
 # numpy.append --> The append() function is used to append values to the end of an given array.
 # The append operation is not inplace, a new array is allocated. 
 # Also the dimensions of the input arrays must match otherwise ValueError will be generated.
 
 # Syntax --> numpy.append(arr, values, axis) 
 
import numpy as np
np.append ([0, 1, 2], [[3, 4, 5], [6, 7, 8]])

Output ::

array([0, 1, 2, 3, 4, 5, 6, 7, 8])

import numpy as np 
a = np.array([[1,2,3],[4,5,6]]) 
print (np.append(a, [7,8,9])) 
print (np.append(a, [[7,8,9]],axis = 0))
print ('\n')  
print ('Append elements along axis 1:') 
print (np.append(a, [[5,5,5],[7,8,9]],axis = 1))

Output ::
print (np.append(a, [7,8,9])) ::
[1 2 3 4 5 6 7 8 9]

print (np.append(a, [[7,8,9]],axis = 0)) :: 

[[1 2 3]
 [4 5 6]
 [7 8 9]]


Append elements along axis 1:

print (np.append(a, [[5,5,5],[7,8,9]],axis = 1)) :: 

[[1 2 3 5 5 5]
 [4 5 6 7 8 9]]
 
 
# numpy.insert --> This function inserts values in the input array along the given axis and before the given index. 
# If the type of values is converted to be inserted, it is different from the input array. 
# Insertion is not done in place and the function returns a new array. 
# Also, if the axis is not mentioned, the input array is flattened.

# Syntax --> numpy.insert(arr, obj, values, axis) 

Obj --> The index before which insertion is to be made.
values --> The array of values to be inserted
axis --> The axis along which to insert. If not given, the input array is flattened.

# Example 1 :: 

import numpy as np 
a = np.array([[1,2],[3,4],[5,6]]) 

print ('First array:') 
print (a)
print ('\n')  

print ('Axis parameter not passed. The input array is flattened before insertion.')
print (np.insert(a,3,[11,12])) 
print ('\n')  
print ('Axis parameter passed. The values array is broadcast to match input array.')

print ('Broadcast along axis 0:') 
print (np.insert(a,1,[11],axis = 0)) 
print ('\n') 

print ('Broadcast along axis 1:') 
print (np.insert(a,1,11,axis = 1))

Output ::

First array:
[[1 2]
 [3 4]
 [5 6]]


Axis parameter not passed. The input array is flattened before insertion.
[ 1  2  3 11 12  4  5  6]


Axis parameter passed. The values array is broadcast to match input array.
Broadcast along axis 0:
[[ 1  2]
 [11 11]
 [ 3  4]
 [ 5  6]]


Broadcast along axis 1:
[[ 1 11  2]
 [ 3 11  4]
 [ 5 11  6]]
 
#numpy.delete ---> This function returns a new array with the specified subarray deleted from the input array. 
# As in case of insert() function, if the axis parameter is not used, the input array is flattened.

# Syntax --> Numpy.delete(arr, obj, axis) 

obj -->Can be a slice, an integer or array of integers, indicating the subarray to be deleted from the input array.
axis --> The axis along which to delete. If not given, the input array is flattened.

# Example 1 ::

import numpy as np 
a = np.arange(12).reshape(3,4) 
print (a) 
print (np.delete(a,5))
print (np.delete(a,1,axis = 1)) 
a = np.array([1,2,3,4,5,6,7,8,9,10]) 
print (np.delete(a, np.s_[::2]))

Output ::

print (a) ::

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
 
print (np.delete(a,5)) ::

[ 0  1  2  3  4  6  7  8  9 10 11]

print (np.delete(a,1,axis = 1))  ::

[[ 0  2  3]
 [ 4  6  7]
 [ 8 10 11]]
 
 print (np.delete(a, np.s_[::2])) ::
 
 [ 2  4  6  8 10]
 
 # numpy.unique --> This function returns an array of unique elements in the input array. 
 # The function can be able to return a tuple of array of unique vales and an array of associated indices. 
 # Nature of the indices depend upon the type of return parameter in the function call.
 
 Syntax --> numpy.unique(arr, return_index, return_inverse, return_counts) 
 
import numpy as np 
a = np.array([5,2,6,2,7,5,6,8,2,9]) 

print ('First array:') 
print (a) 
print ('\n')  

print ('Unique values of first array:') 
u = np.unique(a) 
print (u)
print ('\n')  

print ('Unique array and Indices array:') 
u,indices = np.unique(a, return_index = True) 
print (indices)
print ('\n')  

print ('We can see each number corresponds to index in original array:') 
print (a)
print ('\n')  

print ('Indices of unique array:') 
u,indices = np.unique(a,return_inverse = True) 
print (u) 
print ('\n') 

print ('Indices are:') 
print (indices)
print ('\n')  

print ('Reconstruct the original array using indices:') 
print (u[indices])
print ('\n')  

print ('Return the count of repetitions of unique elements:') 
u,indices = np.unique(a,return_counts = True) 
print (u) 
print (indices)


Output ::

First array:
[5 2 6 2 7 5 6 8 2 9]


Unique values of first array:
[2 5 6 7 8 9]


Unique array and Indices array:
[1 0 2 4 7 9]


We can see each number corresponds to index in original array:
[5 2 6 2 7 5 6 8 2 9]


Indices of unique array:
[2 5 6 7 8 9]


Indices are:
[1 0 2 0 3 1 2 4 0 5]


Reconstruct the original array using indices:
[5 2 6 2 7 5 6 8 2 9]


Return the count of repetitions of unique elements:
[2 5 6 7 8 9]
[3 2 2 1 1 1]


####################################### NumPy - Binary Operators ########################

# NumPy - bitwise_and --> The bit wise AND operation on the corresponding bit of binary representation of integers in input array.


import numpy as np
a,b = 20,22
print (bin(a))
print (bin(b))
print (np.bitwise_and(a,b))

Output ::
print (bin(a)) :: 0b10100
print (bin(b)) :: 0b10110
print (np.bitwise_and(a,b)) = 20


# NumPy - bitwise_or --> The bitwise OR operation on the corresponding bits of binary representations of integers in input array.

import numpy as np
a,b = 20,22
print (bin(a))
print (bin(b))
print (np.bitwise_or(a,b))

Output ::

0b10100
0b10110
22

# numpy.binary_repr() --> This is binary representation of decimal number. 
# numpy.invert()  --> The invert() function is used to compute bit-wise inversion, or bit-wise NOT, element-wise.

import numpy as np
a=np.invert(np.array([13], dtype = np.uint16)) 
print (a)

Output ::

[65522]

import numpy as np
a=np.invert(np.array([13], dtype = np.uint8)) 
print (a) 

Output ::

[242]


# NumPy - left_shift ---> The numpy.left_shift() function shifts the bits in binary representation of an array element to the left by specified positions. 
# Equal number of 0s are appended from the right.


import numpy as np 
print ('Left shift of 10 by two positions:')
print (np.left_shift(10,2)) 
print ('\n')  
print ('Binary representation of 10:')
print (np.binary_repr(10, width = 8))
print ('\n')  
print ('Binary representation of 40:') 
print (np.binary_repr(40, width = 8))  

Output ::

Left shift of 10 by two positions:
40

Binary representation of 10:
00001010

Binary representation of 40:
00101000

 
#NumPy - right_shift --> The numpy.right_shift() function shift the bits in the binary representation of an array element to the right by specified positions,
# and an equal number of 0s are appended from the left.



import numpy as np 
print ('Right shift 40 by two positions:') 
print (np.right_shift(40,2)) 
print ('\n')
print ('Binary representation of 40:') 
print (np.binary_repr(40, width = 8))
print ('\n')  
print ('Binary representation of 10') 
print (np.binary_repr(10, width = 8)) 

Output ::

Right shift 40 by two positions:
10

Binary representation of 40:
00101000

Binary representation of 10
00001010


####################################### NumPy - Binary Operators ###########################################################

# numpy.char.add() --> This function performs element wise string concatenation.

Example 1 ::

import numpy as np
print (np.char.add(['hello'],['add']))

Output ::
['helloadd']
Hello Hello Hello 
Example 2 :: 

import numpy as np
print (np.char.add(['hello', 'hi'],[' abc', ' xyz']))

Output ::

['hello abc' 'hi xyz']


# numpy.char.multiply() --> This function performs multiple concatenation. 

import numpy as np 
print (np.char.multiply('Hello ',3))

Output ::
Hello Hello Hello 

# numpy.char.center() --> This function returns an array of the required width so that the input string is centered and padded on the left and right with fillchar.

import numpy as np 
# np.char.center(arr, width,fillchar) 
print (np.char.center('hello', 40,fillchar = '*'))

Output ::

*****************hello******************

# numpy.char.capitalize() --> This function returns the copy of the string with the first letter capitalized.

import numpy as np 
print (np.char.center((np.char.capitalize('hello world')),40,fillchar='*'))

Output ::

**************Hello world***************

# numpy.char.title() --> This function returns a title cased version of the input string with the first letter of each word capitalized.

import numpy as np 
print (np.char.center((np.char.title('hello world')),40,fillchar='*'))

Output ::

**************Hello World***************

# numpy.char.lower() --> This function returns an array with elements converted to lowercase.
# It calls str.lower for each element.

import numpy as np 
print (np.char.lower(['HELLO','WORLD'])) 
print (np.char.lower('HELLO'))

Output ::

['hello' 'world']
hello

# numpy.char.upper() --> This function calls str.upper function on each element in an array to return the uppercase array elements.

import numpy as np 
print (np.char.upper('hello')) 
print (np.char.upper(['hello','world']))

Output ::

HELLO
['HELLO' 'WORLD']

# numpy.char.split() --> This function returns a list of words in the input string. 
# By default, a whitespace is used as a separator.
# Otherwise the specified separator character is used to spilt the string

import numpy as np 
print (np.char.split ('hello how are you?'))
print (np.char.split ('TutorialsPoint,Hyderabad,Telangana', sep = ','))

Output ::

['hello', 'how', 'are', 'you?']
['TutorialsPoint', 'Hyderabad', 'Telangana']

#numpy.char.splitlines() --> This function returns a list of elements in the array, breaking at line boundaries.

import numpy as np 
print (np.char.splitlines('hello\nhow are you?')) 
print (np.char.splitlines('hello\rhow are you?'))

Output ::

['hello', 'how are you?']
['hello', 'how are you?']

#numpy.char.strip() --> This function returns a copy of array with elements stripped of the specified characters leading and/or trailing in it.

import numpy as np 
print (np.char.strip('ashok arora','a')) 
print (np.char.strip(['arora','admin','java'],'a'))

Output ::

shok aror
['ror' 'dmin' 'jav']

# numpy.char.join() ---> This method returns a string in which the individual characters are joined by separator character specified.

import numpy as np 
print (np.char.join(':','dmy'))
print (np.char.join([':','-'],['dmy','ymd']))

Output ::

d:m:y
['d:m:y' 'y-m-d']

# numpy.char.replace() --> This function returns a new copy of the input string in which all occurrences of the sequence of characters is replaced by another given sequence.

import numpy as np 
print (np.char.replace ('He is a good boy', 'is', 'was'))

Output ::

He was a good boy

# numpy.char.decode() --> This function calls numpy.char.decode() decodes the given string using the specified codec.

import numpy as np 
a = np.char.encode('hello', 'cp500') 
print (a)
print (np.char.decode(a,'cp500'))

Output ::

b'\x88\x85\x93\x93\x96'
hello

####################################### NumPy - Arithmetic Operations ###########################################################

# Input arrays for performing arithmetic operations such as add(), subtract(), multiply(), and divide() must be either of the same shape or should conform to array broadcasting rules.

# Example 1::

import numpy as np 
a = np.arange(9, dtype = np.float_).reshape(3,3) 

print ('First array:')
print (a) 
print ('\n')  

print ('Second array:')
b = np.array([10,10,10]) 
print (b) 
print ('\n')  

print ('Add the two arrays:') 
print (np.add(a,b))
print ('\n')  

print ('Subtract the two arrays:') 
print (np.subtract(a,b))
print ('\n')  

print ('Multiply the two arrays:') 
print (np.multiply(a,b)) 
print ('\n')  

print ('Divide the two arrays:') 
print (np.divide(a,b))

Output ::

First array:
[[0. 1. 2.]
 [3. 4. 5.]
 [6. 7. 8.]]


Second array:
[10 10 10]


Add the two arrays:
[[10. 11. 12.]
 [13. 14. 15.]
 [16. 17. 18.]]


Subtract the two arrays:
[[-10.  -9.  -8.]
 [ -7.  -6.  -5.]
 [ -4.  -3.  -2.]]


Multiply the two arrays:
[[ 0. 10. 20.]
 [30. 40. 50.]
 [60. 70. 80.]]


Divide the two arrays:
[[0.  0.1 0.2]
 [0.3 0.4 0.5]
 [0.6 0.7 0.8]]
 
 # Example 2 :: 

numpy.reciprocal() --> This function returns the reciprocal of argument, element-wise.
# For elements with absolute values larger than 1, the result is always 0 because of the way in which Python handles integer division. 
# For integer 0, an overflow warning is issued.

Receiprocal means :: 

The reciprocal of a number is one divided by that number.
Formally
The reciprocal of x = 1/x
  
So, for example the reciprocal of 4 is one quarter:
The reciprocal of 4 is	 	 
1/4 which is equal to 0.25

Example #2 -->

import numpy as np 
a = np.array([0.25, 1.33, 1, 0, 100]) 
print ('Our array is:') 
print (a) 
print ('\n')  
print ('After applying reciprocal function:') 
print (np.reciprocal(a))
print ('\n')  
b = np.array([100], dtype = int) 
print ('The second array is:')
print (b) 
print ('\n') 
print ('After applying reciprocal function:') 
print (np.reciprocal(b)) 

Output ::

Our array is:
[  0.25   1.33   1.     0.   100.  ]


After applying reciprocal function:
[4.        0.7518797 1.              inf 0.01     ]


The second array is:
[100]


After applying reciprocal function:
[0]
__main__:7: RuntimeWarning: divide by zero encountered in reciprocal

# numpy.power() --> This function treats elements in the first input array as base and returns it raised to the power of the corresponding element in the second input array.

import numpy as np 
a = np.array([10,100,1000]) 
print ('Our array is:') 
print (a) 
print ('\n') 
print ('Applying power function:') 
print (np.power(a,2)) 
print ('\n')  
print ('Second array:') 
b = np.array([1,2,3]) 
print (b) 
print ('\n')  
print ('Applying power function again:') 
print (np.power(a,b))

Output ::

Our array is:
[  10  100 1000]


Applying power function:
[    100   10000 1000000]


Second array:
[1 2 3]


Applying power function again:
[        10      10000 1000000000]


# numpy.mod() --> This function returns the remainder of division of the corresponding elements in the input array. 
# The function numpy.remainder() also produces the same result.

import numpy as np 
a = np.array([10,20,30]) 
b = np.array([3,5,7]) 

print ('First array:')
print (a) 
print ('\n')  

print ('Second array:') 
print (b) 
print ('\n') 

print ('Applying mod() function:')
print (np.mod(a,b))
print ('\n')  

print ('Applying remainder() function:')
print (np.remainder(a,b))

Output ::

First array:
[10 20 30]

Second array:
[3 5 7]

Applying mod() function:
[1 0 2]

Applying remainder() function:
[1 0 2]

###### Operations performed with Complex numbers ################

import numpy as np 
a = np.array([-5.6j, 0.2j, 11. , 1+1j]) 

print ('Our array is:')
print (a) 
print ('\n')  

print ('Applying real() function:') 
print (np.real(a)) 
print ('\n')  

print ('Applying imag() function:') 
print (np.imag(a))
print ('\n')  

print ('Applying conj() function:')
print (np.conj(a)) 
print ('\n')  

print ('Applying angle() function:') 
print (np.angle(a)) 
print ('\n')  

print ('Applying angle() function again (result in degrees)') 
print (np.angle(a, deg = True))

Output ::

Our array is:
[-0.-5.6j  0.+0.2j 11.+0.j   1.+1.j ]


Applying real() function:
[-0.  0. 11.  1.]


Applying imag() function:
[-5.6  0.2  0.   1. ]


Applying conj() function:
[-0.+5.6j  0.-0.2j 11.-0.j   1.-1.j ]


Applying angle() function:
[-1.57079633  1.57079633  0.          0.78539816]


Applying angle() function again (result in degrees)
[-90.  90.   0.  45.]


****************************************NumPy - Statistical Functions******************************************************

# numpy.amin() and numpy.amax() --> These functions return the minimum and maximum from the elements in the given array along with specified axis.

import numpy as np 
a = np.array([[3,7,5],[8,4,3],[2,4,9]]) 
print ('Our array is:') 
print (a) 
print ('\n')  
print ('Applying amin() function:') 
print (np.amin(a,1)) 
print ('\n')  
print ('Applying amin() function again:')
print (np.amin(a,0))
print ('\n')  
print ('Applying amax() function:') 
print (np.amax(a)) 
print ('\n')  
print ('Applying amax() function again:') 
print (np.amax(a, axis = 0))

Output ::

Our array is:
[[3 7 5]
 [8 4 3]
 [2 4 9]]

Applying amin() function:
[3 3 2]

Applying amin() function again:
[2 4 3]

Applying amax() function:
9

Applying amax() function again:
[8 7 9]

#numpy.ptp() --> The numpy.ptp() function returns the range (maximum-minimum) of values along an axis. 
# Here range = ( maximum - minimum )

import numpy as np 
a = np.array([[3,7,5],[8,4,3],[2,4,9]]) 

print ('Our array is:')
print (a)
print ('\n') 

print ('Applying ptp() function:') 
print (np.ptp(a))
print ('\n')

print ('Applying ptp() function along axis 1:') 
print (np.ptp(a, axis = 1))
print ('\n') 

print ('Applying ptp() function along axis 0:')
print (np.ptp(a, axis = 0)) 

Output ::

Our array is:
[[3 7 5]
 [8 4 3]
 [2 4 9]]

Applying ptp() function:
7

Applying ptp() function along axis 1:
[4 5 7]

Applying ptp() function along axis 0:
[6 3 6]

# numpy.percentile() --> Percentile (or a centile) is a measure used in statistics indicating the value below which a given percentage of observations in a group of observations fall. 
# numpy.percentile()  --> numpy.percentile(a, q, axis)

import numpy as np 
a = np.array([[30,40,70],[80,20,10],[50,90,60]]) 

print ('Our array is:')
print (a)
print ('\n') 

print ('Applying percentile() function:') 
print (np.percentile(a,50))
print ('\n')  

print ('Applying percentile() function along axis 1:') 
print (np.percentile(a,50, axis = 1))
print ('\n')

print ('Applying percentile() function along axis 0:') 
print (np.percentile(a,50, axis = 0))

Output ::

Our array is:
[[30 40 70]
 [80 20 10]
 [50 90 60]]

Applying percentile() function:
50.0

Applying percentile() function along axis 1:
[40. 20. 60.]

Applying percentile() function along axis 0:
[50. 40. 60.]

# numpy.median() --> This function defines as the value separating the higher half of a data sample from the lower half.

# How to find Median for numbers
1.Arrange the numbers in order by size.
2.If there is an odd number of terms, the median is the center term.
3.If there is an even number of terms, add the two middle terms and divide by 2

import numpy as np 
a = np.array([[30,65,70],[80,95,10],[50,90,60]]) 

print ('Our array is:')
print (a)
print ('\n')  

print ('Applying median() function:') 
print (np.median(a))
print ('\n') 

print ('Applying median() function along axis 0:') 
print (np.median(a, axis = 0))
print ('\n')  
 
print ('Applying median() function along axis 1:') 
print (np.median(a, axis = 1))

Output ::

Our array is:
[[30 65 70]
 [80 95 10]
 [50 90 60]]

Applying median() function:
65.0

Applying median() function along axis 0:
[50. 90. 60.]

Applying median() function along axis 1:
[65. 80. 60.]

#numpy.mean() --> Arithmetic mean is the sum of elements along an axis divided by the number of elements. 
# The numpy.mean() function returns the arithmetic mean of elements in the array


import numpy as np 
a = np.array([[1,2,3],[3,4,5],[4,5,6]]) 

print ('Our array is:')
print (a) 
print ('\n') 

print ('Applying mean() function:') 
print (np.mean(a)) 
print ('\n')  

print ('Applying mean() function along axis 0:') 
print (np.mean(a, axis = 0)) 
print ('\n')  

print ('Applying mean() function along axis 1:') 
print (np.mean(a, axis = 1))

Output ::

Our array is:
[[1 2 3]
 [3 4 5]
 [4 5 6]]

Applying mean() function:
3.6666666666666665

Applying mean() function along axis 0:
[2.66666667 3.66666667 4.66666667]

Applying mean() function along axis 1:
[2. 4. 5.]


# numpy.average() --> This will calculate the weighted average of elements in an array according to their respective weights gieven in another array.
# Below is normal average function. 

import numpy as np
a=list(range(1,5))
print (np.average(a))

# The numpy.average() function computes the weighted average of elements in an array according to their respective weight given in another array.

Considering an array [1,2,3,4] and corresponding weights [4,3,2,1], the weighted average is calculated by adding the product of the corresponding elements and dividing the sum by the sum of weights.

# Weighted average = (1*4+2*3+3*2+4*1)/(4+3+2+1)

import numpy as np 
a = np.array([1,2,3,4]) 

print ('Our array is:') 
print (a) 
print ('\n')  

print ('Applying average() function:') 
print (np.average(a)) 
print ('\n') 

# this is same as mean when weight is not specified 
wts = np.array([4,3,2,1]) 
print (wts)

print ('Applying average() function again:')
print (np.average(a,weights = wts)) 
print ('\n')  

# Returns the sum of weights, if the returned parameter is set to True. 
print ('Sum of weights')
print (np.average([1,2,3, 4],weights = [4,3,2,1], returned = True))


Output ::

Our array is:
[1 2 3 4]

Applying average() function:
2.5

[4 3 2 1]
Applying average() function again:
2.0

Sum of weights
(2.0, 10.0)

# Standard Deviation --> Standard deviation is the square root of the average of squared deviations from mean. 
# The formula for standard deviation is as follows.

# std = sqrt(mean(abs(x - x.mean())**2))

import numpy as np 
print (np.std([1,2,3,4]))

Output ::

1.118033988749895

# Variance --> Variance is the average of squared deviations.

import numpy as np 
print (np.var([1,2,3,4]))

Output :: 

1.25

############################################## NumPy - Sort, Search & Counting Functions #################################################

# Numpy support variety of sorting functions.These sorting functions implments different sorting algorithms. 
# Each of them have different characterstics , speed of execution , worst case performance, work space requried and stability of algorithms.

# We have 3 sorts in Numpy --> i) quicksort ii) mergesort iii) heapsort 

# numpy.sort() --> This function returns the sorted copy of the input array. 
# Synatx --> numpy.sort(a, axis, kind, order)
# If we don't specify any order default that order will be quicksort.

import numpy as np
a=np.array([[3,7],[1,2]])
print (a)
print(np.sort(a,axis=0))

dt=np.dtype([('name','S10'),('age',int)])
b=np.array([("test",21),("yyy",12),("uuu",13)],dtype=dt)
print (b)
print (np.sort(b, order = 'name'))

Output ::

[[3 7]
 [1 2]]
[[1 2]
 [3 7]]
[(b'test', 21) (b'yyy', 12) (b'uuu', 13)]
[(b'test', 21) (b'uuu', 13) (b'yyy', 12)]

# numpy.argsort() --> This function will do an indirect sort of input array along with given axis specified by the kind of keyword.

Example :: 

import numpy as np 
# input array 
in_arr = np.array([ 2, 0, 1, 5, 4, 1, 9]) 
print ("Input unsorted array : ", in_arr) 

out_arr = np.argsort(in_arr) 
print ("Output sorted array indices : ", out_arr) 
print("Output sorted array : ", in_arr[out_arr]) 

Output ::

Input unsorted array :  [2 0 1 5 4 1 9]
Output sorted array indices :  [1 2 5 0 4 3 6]
Output sorted array :  [0 1 1 2 4 5 9]


# numpy.lexsort() --> 
# Performs indirect sort using a sequence of keys
# Sort by a, then by b 
# Return the type ndarray of integers array of indicated the sort of the keys along the specified axis
# Occupies species as new array of sorted indices pair wise is returned


import numpy as np 

# Numpy array created 
a =  ('raju','anil','ravi','amar')  # First column 
b = ('f.y.', 's.y.', 's.y.', 'f.y.')  # Second column 
print (a)
print (b)
print('column a, column b') 
for (i, j) in zip(a, b): 
	print(i, ' ', j) 

ind = np.lexsort((b, a)) # Sort by a then by b 
print('Sorted indices->', ind) 

Output ::

('raju', 'anil', 'ravi', 'amar')
('f.y.', 's.y.', 's.y.', 'f.y.')
column a, column b
raju   f.y.
anil   s.y.
ravi   s.y.
amar   f.y.
Sorted indices-> [3 1 0 2]

# numpy.argmax() and numpy.argmin()  --> These functions used to find maximum number and minimimum number in an array for the given axis.

# The argmax() indicates the max number indexes in an array.

# Python Program illustrating 
# working of argmax() 

import numpy as geek 

# Working on 2D array 
array = geek.arange(12).reshape(3, 4) 
print("INPUT ARRAY : \n", array) 

# No axis mentioned, so works on entire array 
print("\nMax element : ", geek.argmax(array)) 

# returning Indices of the max element 
# as per the indices 
print("\nIndices of Max element : ", geek.argmax(array, axis=0)) 
print("\nIndices of Max element : ", geek.argmax(array, axis=1)) 

Output ::

Our array is:
[[30 40 70]
 [80 20 10]
 [50 90 60]]


Applying argmax() function:
7

Index of maximum number in flattened array
[30 40 70 80 20 10 50 90 60]

Array containing indices of maximum along axis 0:
[1 2 0]

Array containing indices of maximum along axis 1:
[2 0 1]

Applying argmin() function:
5

Flattened array:
10

Flattened array along axis 0:
[0 1 1]

Flattened array along axis 1:
[0 2 0]

#numpy.nonzero()-->This function is used to Compute the indices of the elements that are non-zero.
#It returns a tuple of arrays, one for each dimension of arr, containing the indices of the non-zero elements in that dimension.
#The corresponding non-zero values in the array can be obtained with arr[nonzero(arr)] .
#To group the indices by element, rather than dimension we can use transpose(nonzero(arr)).

import numpy as np
a=np.array([[30,40,50],[0,3,44],[89,23,44]])
print (a)
b=np.nonzero(a)
print (b)

Output ::

[[30 40 50]
 [ 0  3 44]
 [89 23 44]]
(array([0, 0, 0, 1, 1, 2, 2, 2], dtype=int64), array([0, 1, 2, 1, 2, 0, 1, 2], dtype=int64))

Example 2 :: 

import numpy as np
a=np.array([[30,40,50],[20,3,44],[89,23,44]])
print (a)
b=np.nonzero(a)
print (b)

Output ::

[[30 40 50]
 [20  3 44]
 [89 23 44]]
(array([0, 0, 0, 1, 1, 1, 2, 2, 2], dtype=int64), array([0, 1, 2, 0, 1, 2, 0, 1, 2], dtype=int64))

# numpy.where() --> The where() function returns the indices of elements in an input array where the given condition is satisfied.

Example 1 :: 

import numpy as np 
x = np.arange(9.).reshape(3, 3) 
print ('Our array is:') 
print (x)  
print ('Indices of elements > 3') 
y = np.where(x > 3) 
print (y)
print ('Use these indices to get elements satisfying the condition') 
print (x[y])

Output :: 

Our array is:
[[0. 1. 2.]
 [3. 4. 5.]
 [6. 7. 8.]]
Indices of elements > 3
(array([1, 1, 2, 2, 2], dtype=int64), array([1, 2, 0, 1, 2], dtype=int64))
Use these indices to get elements satisfying the condition
[4. 5. 6. 7. 8.]

#numpy.extract() --> The extract() function returns the elements satisfying any condition


import numpy as np 
x = np.arange(9.).reshape(3, 3) 
print 'Our array is:' 
print x  
# define a condition 
condition = np.mod(x,2) == 0 
print 'Element-wise value of condition' 
print condition  
print 'Extract elements using condition' 
print np.extract(condition, x)

Output ::

Our array is:
[[0. 1. 2.]
 [3. 4. 5.]
 [6. 7. 8.]]
Element-wise value of condition
[[ True False  True]
 [False  True False]
 [ True False  True]]
Extract elements using condition
[0. 2. 4. 6. 8.]

********************************************** NumPy - Byte Swapping ******************************************
# numpy.ndarray.byteswap() --> 
# We have seen the data stored in the memory of a computer depend on which architecture the CPU uses.
# it may be little-endian ( least significant is stored in the smallest adderss ) Or big-endian ( most significant byte in the smallest address ).

import numpy as np 
a = np.array([1, 256, 8755], dtype = np.int16) 

print ('Our array is:') 
print (a)  

print ('Representation of data in memory in hexadecimal form:')  
print (map(hex,a))  
# byteswap() function swaps in place by passing True parameter 

print ('Applying byteswap() function:') 
print (a.byteswap(True)) 

print ('In hexadecimal form:') 
print (map(hex,a)) 
# We can see the bytes being swapped

Output ::

Our array is:
[   1  256 8755]

Representation of data in memory in hexadecimal form:
<map object at 0x0000014B28636358>

Applying byteswap() function:
[  256     1 13090]
In hexadecimal form:
<map object at 0x0000014B28636358>

**************************************** NumPy - Copies & Views ********************************************

# While executing a function, some of them return a copy of the input array, while some return the view.
# When the contents are physically stored in another location, it is called COPY.
# If different view of same memory provided, we can call it as VIEW.

# numpy.id () --> This will return the universal identifier of python object.
# Change in shape of one , another with copy variable also changed.

import numpy as np 
a = np.arange(6) 

print ('Our array is:') 
print (a) 
print ('\n') 

print ('Applying id() function:') 
print (id(a))  
print ('\n')

print ('a is assigned to b:') 
b = a 
print (b)  
print ('\n')

print ('b has same id():') 
print (id(b))  
print ('\n')

print ('Change shape of b:') 
b.shape = 3,2 
print (b)  
print ('\n')

print ('Shape of a also gets changed:') 
print (a)

Output ::

Our array is:
[0 1 2 3 4 5]


Applying id() function:
1422311736624


a is assigned to b:
[0 1 2 3 4 5]


b has same id():
1422311736624


Change shape of b:
[[0 1]
 [2 3]
 [4 5]]


Shape of a also gets changed:
[[0 1]
 [2 3]
 [4 5]]
 
 
 # NumPy has ndarray.view() method which is a new array object that looks at the same data of the original array.
 
 
 import numpy as np 
# To begin with, a is 3X2 array 
a = np.arange(6).reshape(3,2) 

print ('Array a:' )
print (a) 
print ('\n')

print ('Create view of a:') 
b = a.view() 
print (b ) 
print ('\n')

print ('id() for both the arrays are different:') 
print ('id() of a:')
print (id(a))
print ('\n')
print ('id() of b:') 
print (id(b))

# Change the shape of b. It does not change the shape of a 
b.shape = 2,3 

print ('Shape of b:') 
print (b)
print ('\n')

print ('Shape of a:') 
print (a)


Output ::

Array a:
[[0 1]
 [2 3]
 [4 5]]


Create view of a:
[[0 1]
 [2 3]
 [4 5]]


id() for both the arrays are different:
id() of a:
1422311737424


id() of b:
1422307000448
Shape of b:
[[0 1 2]
 [3 4 5]]


Shape of a:
[[0 1]
 [2 3]
 [4 5]]
 
 # ndarray.copy() --> The ndarray.copy() function creates a deep copy. 
 # It is a complete copy of the array and its data, and doesn’t share with the original array.
 
 import numpy as np 
a = np.array([[10,10], [2,3], [4,5]]) 

print ('Array a is:') 
print (a)

print ('Create a deep copy of a:')
b = a.copy() 
print ('Array b is:')
print (b)

#b does not share any memory of a 
print ('Can we write b is a') 
print (b is a)

print ('Change the contents of b:') 
b[0,0] = 100 

print ('Modified array b:') 
print (b)  

print ('a remains unchanged:') 
print (a)

Output ::

Array a is:
[[10 10]
 [ 2  3]
 [ 4  5]]
Create a deep copy of a:
Array b is:
[[10 10]
 [ 2  3]
 [ 4  5]]
Can we write b is a
False
Change the contents of b:
Modified array b:
[[100  10]
 [  2   3]
 [  4   5]]
a remains unchanged:
[[10 10]
 [ 2  3]
 [ 4  5]]
 
 ******************************************** NumPy - Matrix Library ******************************************
 
 
 



