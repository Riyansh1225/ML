# Examples for ndarray Concept :: 

# numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0) --> This is syntax of the array object in 

# In this example depending on dtype output values will be changed. 
# Means we can convert the elements in an array by defining the data type.

import numpy as np
a=np.array([1,2,3,4,5,6], dtype = int )
print(a)

Output ::

[1 2 3 4 5 6]

# Run the same program in 2 dimensions array 

import numpy as np
a=np.array([[1,2,3,4],[5,6,7,8]] , dtype = float )
print (a)

Output :: 

[[1. 2. 3. 4.]
 [5. 6. 7. 8.]]


# Examples for Data type in NumPy  :: 

#  numpy.dtype(object, align, copy)  --> This is syntax of dtype in Numpy.

# This is basic example of the Numpy array

import numpy as np
a=np.dtype(int)
print (a)

Output :: 
int32

#int8, int16, int32, int64 can be replaced by equivalent string 'i1', 'i2','i4', etc.

import nupy as np
a=np.dtype('i4')
print (a)

OutPut :: 
int32

# Create structured data type and used to display the contenent on the array 

import numpy as np
a=np.dtype([('Name','S20'),('Marks','i4'),('Ranks','i4')])
b=np.array([('Phani',70,4),('Ram',60,5),('Sai',59,6)] , dtype=a)
print (b['Marks'])

OutPut :: [70 60 59]

#Examples for Array Attributes in Numpy 

# Display shape of the array ( Matrix formte : Rows * Columns )

import numpy as np
a=np.array([(1,2,3,4,5,6,7),(3,4,5,6,7,8,9)], dtype=int)
print (a.shape)

OutPut :: (2, 7)

# We can reshape the matrix 

import numpy as np
a=np.array([(1,2,3),(4,5,6)], dtype=float)
print (a.shape)
b = a.reshape(3,2)
print(b)

OutPut ::

(2, 3)

[[1. 2.]
 [3. 4.]
 [5. 6.]]

# We can resize the matrix

import numpy as np
a=np.array([(1,2,3),(4,5,6)], dtype=float)
print (a.shape)
a.shape=(3,2)
print(a)

OutPut ::
(2, 3)

[[1. 2.]
 [3. 4.]
 [5. 6.]]


# An array of evenly spaced numbers

import numpy as np
a=np.arange(15)
print (a)

Output :: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]

# Display the list of numbers in a range. Here End number won't be considered.

import numpy as np
a=np.arange(16).reshape(4,2,2)
print (a)
a.ndim

OutPut ::

[[[ 0  1]
  [ 2  3]]

 [[ 4  5]
  [ 6  7]]

 [[ 8  9]
  [10 11]]

 [[12 13]
  [14 15]]]
  
  a.ndim
  
  3

## Size , Itemsize and nbytes  Definations 

# Size :: This will display the number of elements in an array

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.size)

Output :: 10

# itemsize :: This will display memory used by each array element in an array

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.itemsize)

Output :: 4 

# nbytes :: The total number of bytes required to store array data ( size * item size )

import numpy as np
a=np.array([1,2,3,4,4,55,5,5,5,5])
print (a.nbytes)

Output :: 40 

# Flags in Numpy Library

import numpy as np
x = np.array([1,2,3,4,5])
print x.flags

Output ::

C_CONTIGUOUS : True
F_CONTIGUOUS : True
OWNDATA : True
WRITEABLE : True
ALIGNED : True
UPDATEIFCOPY : False

# Numpy ---> ARRAY CREATION ROUTINES

# numpy.empty --> It creates an uninitialized array of specified shape and dtype. It uses the following constructor.

Syntax :: numpy.empty(shape, dtype=float, order='C')

Note :: The elements in an array show random values as they are not initialized.

import numpy as np
a=np.empty((3,2),dtype=int)
print (a)

Output :: 

[[         0 1074266112]
 [         0 1073741824]
 [         0 1074266112]]
 
 #numpy.zeros --> Returns a new array of specified size, filled with zeros.
 
 synatx --> numpy.zeros(shape, dtype=float, order='C')
 
 import numpy as np
 a=np.zeros([2,3,4], dtype = float)
 print (a) 
 
 Output ::
 
 [[[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
  
  #numpy.ones --> Returns a new array of specified size and type, filled with ones
  
  Syntax : numpy.ones(shape, dtype=None, order='C')
  
 import numpy as np
 a=np.ones([2,3,4], dtype = float)
 print (a) 
 
  Output ::
  
  [[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]]
  
# NUMPY − ARRAY FROM EXISTING DATA ::

#numpy.asarray --> This function is similar to numpy.array except for the fact that it has fewer parameters. 
#This routine is useful for converting Python sequence into ndarray.

#Synatax --> numpy.asarray(a, dtype=None, order=None)

import numpy as np
a=np.asarray([1,2,3,4,5,6,7] , dtype = complex )
print (a)

Output :: [1.+0.j 2.+0.j 3.+0.j 4.+0.j 5.+0.j 6.+0.j 7.+0.j]

# numpy.frombuffer --> This function interprets a buffer as one-dimensional array.
# Any object that exposes the buffer interface is used as parameter to return an ndarray.

Syntax --> numpy.frombuffer(buffer, dtype=float, count=-1, offset=0)

import numpy as np
b="My first Python Program"
a=np.frombuffer(b,dtype=S1)
print (a)

Output :: Not working in Spyder , Need to check in Jupyter note pad.

#This function builds an ndarray object from any iterable object. 
# A new one-dimensional array is returned by this function.
Syntax --> numpy.fromiter(iterable, dtype, count=-1)

import numpy as np
def gen_c():
    c = np.ones(5, dtype=int)
    j = 0
    t = 10
    while j < t:
        c[0] = j
        for i in c:
            yield i
        j += 1

np.fromiter(gen_c(),dtype=int).reshape((10,5))

Output ::

array([[0, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [2, 1, 1, 1, 1],
       [3, 1, 1, 1, 1],
       [4, 1, 1, 1, 1],
       [5, 1, 1, 1, 1],
       [6, 1, 1, 1, 1],
       [7, 1, 1, 1, 1],
       [8, 1, 1, 1, 1],
       [9, 1, 1, 1, 1]])
  
# NUMPY − ARRAY FROM NUMERICAL RANGES

numpy.arange --> This function returns an ndarray object containing evenly spaced values within a given range.
Syntax --> numpy.arange(start, stop, step, dtype)

import numpy as np
a=np.arange(3,30,3)
print (a)

Output :: 

[ 3  6  9 12 15 18 21 24 27]

# numpy.linspace  --> This function is similar to arange() function. 
# In this function, instead of step size, the number of evenly spaced values between the interval is specified.

Syntax --> numpy.linspace(start, stop, num, endpoint, retstep, dtype)

import numpy as np
a=np.linspace(2,40,10)
print (a)

Output ::

[ 2.          6.22222222 10.44444444 14.66666667 18.88888889 23.11111111
 27.33333333 31.55555556 35.77777778 40.        ]
 

# numpy.linspace -->  Return evenly spaced numbers over a specified interval.
# Returns num evenly spaced samples, calculated over the interval [start, stop].
# The endpoint of the interval can optionally be excluded.

Syntax --> numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)

start --> Starting value of the sequence. 
Stop  --> The end value of the sequence, unless endpoint is set to False.

import numpy as np
a=np.linspace(2,3,4 , endpoint = False , retstep = True )
print (a)

OutPut ::  
         (array([2.  , 2.25, 2.5 , 2.75]), 0.25) 
         
         Here 0.25 is step size in a sample array.

In the above example, if we don't specify the retstep as True, step size won't be displayed.

# numpy.logspace  --> Return numbers spaced evenly on a log scale.

# In linear space, the sequence starts at base ** start (base to the power of start) and ends with base ** stop

Syntax --> numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)

import numpy as np
a=np.linspace(1,10,num=10)
print (a)

Output :: [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]

import numpy as np
a=np.logspace(1,10,num=9,dtype=int,endpoint=false)
print (a)

Output :: [         10         100        1000       10000      100000     1000000
    10000000   100000000  1000000000 -2147483648]
  

import numpy as np
a=np.logspace(1,10,num=9,dtype=int,base=2,endpoint=False)
print (a)

Output :: [  2   4   8  16  32  64 128 256 512]

********************************* Indexing and Slicing *************************************

indexing or slicing, just like Python's in-built container objects. Items in ndarray are based on zero-based index. 

Below are 3 types of methods are available 

1.field access 
2.basic slicing 
3.adavanced indexing 

1.Filed accesss ::

import numpy as np
a=np.arange(24)
print (a)
b=a[2:7:2]
print (b)

Output ::

print (a) :: 

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]

print (b) :: 

[2 4 6]


2.Basic Slicing ::

import numpy as np
a=np.arange(5)
print (a)
b=a[2:]
print (b)

Output ::

print (a) ::

[0 1 2 3 4]

Print (b) ::
[2 3 4]

Anothe Example for Simple Slicing ::

import numpy as np
a=np.array([[1,2,3],[4,5,6],[7,8,9]], dtype = int)
print (a)
b=a[-2:]
print (b)

Output ::

print (a) ::

[[1 2 3]
 [4 5 6]
 [7 8 9]]
 
print (b) ::

[[4 5 6]
 [7 8 9]]
 
 
#Accessing the column values from the matrix. we can use ellipsis(...) to get the column or row values in particular.
#If we place the ellipsis in the row position, it will get you the all the values of particular column
c=np.array([[1,2,3,4],[5,6,7,8],[9,8,7,6]],int)
c
c[...,1]
c[1,...]
c[...,2]

#Accessing the row values from diagonal matrix.If we place the ellipsis in the column value 
#position, it will get you the all the values of particular row mentioned
c[1]
c[1,...]

#Slicing
a=np.arange(20)
a
a[5:20:5]
a[:4] #means from 0th index to before 4th index.
a[:10]
a[1:5] #means from first index to before 5th index.
a[5:] #means from 5th index to last index.
a[::4] #means multiples of 4 until last values.
a[0]

************************************ Advanced Indexing *****************************************

# This mechanism helps in selecting any arbitrary item in an array based on its Ndimensional index.
# Each integer array represents the number of indexes into that dimension. 
# When the index consists of as many integer arrays as the dimensions of the target ndarray, it becomes straightforward.

Simple Indexing example ::

import numpy as np
a=np.array([[1,2,3,4],[4,5,6,7],[7,8,9,10]])
print (a)
print(a[[1,2,1,0],[0,2,3,3]])

Output ::
print (a) :: 

[[ 1  2  3  4]
 [ 4  5  6  7]
 [ 7  8  9 10]]

print (b) :: [4 9 7 4]

#############

import numpy as np 
x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
print (x)
rows = np.array([[0,0],[3,3]])
print (rows)
cols = np.array([[0,2],[0,2]])
print (cols) 
y = x[rows,cols] 
print (y)


Output ::

print (x) :
 [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (rows) ::
 
 [[0 0]
 [3 3]]
 
 print (cols) ::
 
 [[0 2]
 [0 2]]
 
 print (y) ::
 
 [[ 0  2]
 [ 9 11]]
 
 ######################################
 
 # The advanced and basic indexing can be combined using one slic(:) or ellipise (...) with an index array. 
    
import numpy as np 
x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]]) 
print (x)
# slicing 
a = x[1:4]
print (a)
b = x[1:3]
print (b)
z = x[1:4,1:3] 
print (z) 

# using advanced index for column 
y = x[1:4,[1,2]] 

print (y)

Output :: 
print (x) ::

 [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (a) ::
 
 [[ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
 
 print (b) ::
 
 [[3 4 5]
 [6 7 8]]
 
 print (z) ::
 
 [[ 4  5]
 [ 7  8]
 [10 11]]
 
 print (y) ::
 
 [[ 4  5]
 [ 7  8]
 [10 11]]
 
 ***************************************************************
# Boolen array indexing 
# This type of advanced indexing is used when the resultant object is meant to be the result of Boolean operations, 
# such as comparison operators.

import numpy as np
a=np.array([[0,1,2,3],[4,5,6,7],[6,7,8,9]])
print (a)
print (a[a>3])

Output :: 

[[0 1 2 3]
 [4 5 6 7]
 [6 7 8 9]]
 
 [4 5 6 7 6 7 8 9]
 
 #####################
 
 # In this example, NaN (Not a Number) elements are omitted by using ~ (complement operator)
 
 import numpy as np
 a=np.array([[1,2,np.nan,3],[4,5,6,np.nan],[9,8,7,6]])
 print (a)
 print (a[np.isnan(a)])
 print (a[~np.isnan(a)])
 
Output ::
print (a) ::

[[ 1.  2. nan  3.]
 [ 4.  5.  6. nan]
 [ 9.  8.  7.  6.]]
 
 print (a[np.isnan(a)]) :: [nan nan]
 print (a[~np.isnan(a)]) ::
 
 [1. 2. 3. 4. 5. 6. 9. 8. 7. 6.]
 
 ###########################################
 
 #The following example shows how to filter out the non-complex elements from an array.
 
import numpy as np 
a = np.array([1, 2+6j, 5, 3.5+5j]) 
print a[np.iscomplex(a)]

Output ::

[2.0+6.j  3.5+5.j] 

*************** Numpy - Broadcasting ***************************************************

# The Broadcasting refers to ability of Numpy to treat arrays of different shapes during arithmetic operations. 
# The arithmetic operations on two arrays normally done on array elements.
# if the arrays of same size we don't have any Issues.The arithmatic operations on different sizes will make some difficult.

# This is simple example of multiplication of two arrays of same size 

import numpy as np
a=np.array([[1,2,3],[4,5,6],[7,8,9]])
print (a)
b=np.array([[1,2,3],[4,5,6],[7,8,9]])
print (b)
c= a*b
print (c)

Output ::

print (a) ::

[[1 2 3]
 [4 5 6]
 [7 8 9]]
 
 print (b) ::
 
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
 
 print (c) ::
 
 [[ 1  4  9]
 [16 25 36]
 [49 64 81]]
 
 
# Multiplication of two matrix. Below is thumb rule for the same.
# The number of columns in first matrix is equal to number of rows in secons matrix.
# Below is some example for the same.
# We don't have separate functions in Numpy to support this functionality. Normal for Or while loops we need to use for same.
 

import numpy as np
A=np.array([[12,7,3],[4,5,6],[7,8,9]])
B=np.array([[5,8,1,2],[6,7,3,0],[4,5,9,1]])
C=np.array([[0,0,0,0],[0,0,0,0],[0,0,0,0]])
	
# iterating by row of A 
for i in range(len(A)): 

	# iterating by coloum by B 
	for j in range(len(B[0])): 

		# iterating by rows of B 
		for k in range(len(B)): 
			C[i][j] += A[i][k] * B[k][j] 

for r in C: 
	print(r) 
 
 Output ::
 
[114 160  60  27]
[74  97   73  14]
[119 157 112  23]

################################################################################

# Numpy Package contains the Iteration object. It is efficient multidimensional iteration object. 
# Using this object which we can iterate the each element in the array.

# This is sample program to iterate all the objects in an array.

import numpy as np
a=np.arange(0,60,5)
print (a)
a=a.reshape(4,3)
print (a)

for x in np.nditer(a):
    print (x)
    
OutPut :: 

print (a) :: [ 0  5 10 15 20 25 30 35 40 45 50 55]

print (a) :: 

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
print (x) ::

0
5
10
15
20
25
30
35
40
45
50
55
 
# Reading memory in contigous location is faster than jumping around among locations. 
# As a result, if the matrix stored in row-major order , then iterating through its elements sequencetially in row-major order
# may be faster than iterating elements in column-major order.

# C uses row major and Fortan uses Column major order. 
# Transpose means chaning columns to rows and rows to columns in a matrix.
 
import numpy as np
a=np.arange(0,60,5)
print (a)
print ('\n')
print (a.T)
a=a.reshape(4,3)
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
for x in np.nditer(a.T.copy(order='C')):
    print (x)
    
Output ::

print (a) :: [ 0  5 10 15 20 25 30 35 40 45 50 55]

print (a.T) :: [ 0  5 10 15 20 25 30 35 40 45 50 55] 

After reshape the array 

print (a) ::

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
 print (a.T) ::
 
 [[ 0 15 30 45]
 [ 5 20 35 50]
 [10 25 40 55]]
 
  print (x) ::
  
0
15
30
45
5
20
35
50
10
25
40
55

# In the below example , just chaning the order from C to Fortan.

import numpy as np
a=np.arange(0,60,5)
print (a)
print ('\n')
print (a.T)
a=a.reshape(4,3)
print ('\n After reshape the array')
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
for x in np.nditer(a.T.copy(order='F')):
    print (x)
    
Output ::

0
5
10
15
20
25
30
35
40
45
50
55


# Modifying the array values using nditer object.
# By default ,the nditer object treats the input operand as read-only object.To be able to modify the array elements, you must specify the 
# read-write or write-only mode using the 'readwrite' or 'writeread' per-operand flag.	
# The nditer object has another optional parameter called op_flags.

# Below one is one simple example of how the nditer object is modying the array.

    
import numpy as np
a=np.arange(0,60,5)
a=a.reshape(4,3)
print ('\n After reshape the array')
print (a)
print ('\n')
print (a.T)
print ('\n Final outout of array')
print ('\n')
b=a.T.copy(order='C')
print (b)
for x in np.nditer(b , op_flags = ['readwrite']):
    x[...] = 2*x
    print (x)
    
 Output ::
 
 Print (b) ::
 
 [[ 0 15 30 45]
 [ 5 20 35 50]
 [10 25 40 55]]
 
 print (x) ::
 
 0
30
60
90
10
40
70
100
20
50
80
110


# One more example for Modying the nditer array element.

import numpy as np
a=np.arange(0,60,5)
a=a.reshape(4,3)
print (a)
with np.nditer(a,op_flags=['readwrite']) as it:
    for x in it:
        x[...] = 2*x
print (a)

Output ::

print (a) ::

[[ 0  5 10]
 [15 20 25]
 [30 35 40]
 [45 50 55]]
 
 print (a) ::
 
 [[  0  10  20]
 [ 30  40  50]
 [ 60  70  80]
 [ 90 100 110]]
 
 
 # In the above example we are using WITH statement. Here WITH statement used as context manager. 
 # The temporary data will be written back when the context is exited.
 # One more method is ,  call the close method one finished iterating , which will triger the write-back.
 
 #### Using the External loop # #######
 
 import numpy as np 
a = np.arange(6) 
a = a.reshape(2,3) 
print (a)
for x in np.nditer(a, flags = ['external_loop'], order = 'F'):
   print (x,end=' ')
   
   Output ::
 
 [[0 1 2]
 [3 4 5]]
 
 print (x,end=' ') ::
 
 [0 3] [1 4] [2 5] 
 
 
 
 
 





 








